[{"title":"web前端常见安全问题和对策","date":"2018-03-14T09:15:02.000Z","path":"2018/03/14/web前端常见安全问题和对策/","text":"跨站脚本攻击(XSS攻击) XSS(Cross Site Scripting)，跨站脚本攻击。XSS是常见的Web攻击技术之一.所谓的跨站脚本攻击指得是:恶意攻击者往Web页面里注入恶意Script代码，用户浏览这些网页时，就会执行其中的恶意代码，可对用户进行盗取cookie信息、会话劫持等各种攻击. 解决方案: 1.输入过滤。永远不要相信用户的输入，对用户输入的数据做一定的过滤。 2.输出编码。服务器端输出到浏览器的数据，可以使用系统的安全函数来进行编码或转义来防范XSS攻击。在PHP中，有htmlentities()和htmlspecialchars()两个函数可以满足安全要求。相应的JavaScript的编码方式可以使用JavascriptEncode。 3.安全编码。开发需尽量避免Web客户端文档重写、重定向或其他敏感操作，同时要避免使用客户端数据，这些操作需尽量在服务器端使用动态页面来实现。 4.HttpOnly Cookie。预防XSS攻击窃取用户cookie最有效的防御手段。Web应用程序在设置cookie时，将其属性设为HttpOnly，就可以避免该网页的cookie被客户端恶意JavaScript窃取，保护用户cookie信息。 5.WAF(Web Application Firewall)，Web应用防火墙，主要的功能是防范诸如网页木马、XSS以及CSRF等常见的Web漏洞攻击。由第三方公司开发，在企业环境中深受欢迎。 跨站请求伪造(CSRF攻击) CSRF(Cross Site Request Forgery)，即跨站请求伪造，是一种常见的Web攻击，但很多开发者对它很陌生。CSRF也是Web安全中最容易被忽略的一种网站攻击。 CSRF攻击的原理:CSRF攻击过程的受害者用户登录网站A，输入个人信息，在本地保存服务器生成的cookie。然后在A网站点击由攻击者构建一条恶意链接跳转到B网站,然后B网站携带着的用户cookie信息去访问B网站.让A网站造成是用户自己访问的假相,从而来进行一些列的操作,常见的就是转账. 解决方案：1.验证码。应用程序和用户进行交互过程中，特别是账户交易这种核心步骤，强制用户输入验证码，才能完成最终请求。在通常情况下，验证码够很好地遏制CSRF攻击。但增加验证码降低了用户的体验，网站不能给所有的操作都加上验证码。所以只能将验证码作为一种辅助手段，在关键业务点设置验证码。 2.Referer Check。HTTP Referer是header的一部分，当浏览器向web服务器发送请求时，一般会带上Referer信息告诉服务器是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。可以通过检查请求的来源来防御CSRF攻击。正常请求的referer具有一定规律，如在提交表单的referer必定是在该页面发起的请求。所以通过检查http包头referer的值是不是这个页面，来判断是不是CSRF攻击。但在某些情况下如从https跳转到http，浏览器处于安全考虑，不会发送referer，服务器就无法进行check了。若与该网站同域的其他网站有XSS漏洞，那么攻击者可以在其他网站注入恶意脚本，受害者进入了此类同域的网址，也会遭受攻击。出于以上原因，无法完全依赖Referer Check作为防御CSRF的主要手段。但是可以通过Referer Check来监控CSRF攻击的发生。 3.Anti CSRF Token。目前比较完善的解决方案是加入Anti-CSRF-Token，即发送请求时在HTTP 请求中以参数的形式加入一个随机产生的token，并在服务器建立一个拦截器来验证这个token。服务器读取浏览器当前域cookie中这个token值，会进行校验该请求当中的token和cookie当中的token值是否都存在且相等，才认为这是合法的请求。否则认为这次请求是违法的，拒绝该次服务。这种方法相比Referer检查要安全很多，token可以在用户登陆后产生并放于session或cookie中，然后在每次请求时服务器把token从session或cookie中拿出，与本次请求中的token 进行比对。由于token的存在，攻击者无法再构造出一个完整的URL实施CSRF攻击。但在处理多个页面共存问题时，当某个页面消耗掉token后，其他页面的表单保存的还是被消耗掉的那个token，其他页面的表单提交时会出现token错误。 4.尽量使用POST，限制GET。 mysql注入 SQL注入(SQL Injection)，应用程序在向后台数据库传递SQL(Structured Query Language，结构化查询语言)时，攻击者将SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令. 解决方案:(1) 防止系统敏感信息泄露。设置php.ini选项display_errors=off，防止php脚本出错之后，在web页面输出敏感信息错误，让攻击者有机可乘。(2) 数据转义。设置php.ini选项magic_quotes_gpc=on，它会将提交的变量中所有的’(单引号)，”(双引号)，(反斜杠)，空白字符等都在前面自动加上\\。或者采用mysql_real_escape()函数或addslashes()函数进行输入参数的转义。(3) 增加黑名单或者白名单验证。白名单验证一般指，检查用户输入是否是符合预期的类型、长度、数值范围或者其他格式标准。黑名单验证是指，若在用户输入中，包含明显的恶意内容则拒绝该条用户请求。在使用白名单验证时，一般会配合黑名单验证。(4) 数据库操作通过PDO等方式操作。 文件上传漏洞 上传漏洞在DVBBS6.0时代被黑客们利用的最为猖獗，利用上传漏洞可以直接得到WEBSHELL，危害等级超级高，现在的入侵中上传漏洞也是常见的漏洞。该漏洞允许用户上传任意文件可能会让攻击者注入危险内容或恶意代码，并在服务器上运行。 文件上传漏洞的原理：由于文件上传功能实现代码没有严格限制用户上传的文件后缀以及文件类型，导致允许攻击者向某个可通过 Web 访问的目录上传任意PHP文件，并能够将这些文件传递给 PHP 解释器，就可以在远程服务器上执行任意PHP脚本。 解决方案： (1)检查服务器是否判断了上传文件类型及后缀。 (2) 定义上传文件类型白名单，即只允许白名单里面类型的文件上传。 (3) 文件上传目录禁止执行脚本解析，避免攻击者进行二次攻击。 Info漏洞 Info漏洞就是CGI把输入的参数原样输出到页面，攻击者通过修改输入参数而达到欺骗用户的目的。","tags":[]},{"title":"HTTP协议详解","date":"2018-03-14T02:49:05.000Z","path":"2018/03/14/HTTP协议详解/","text":"什么是HTTP协议&emsp;&emsp;协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器&emsp;&emsp;目前我们使用的是HTTP/1.1 版本 Web服务器，浏览器，代理服务器&emsp;&emsp;当我们打开浏览器，在地址栏中输入URL，然后我们就看到了网页。 原理是怎样的呢？&emsp;&emsp;实际上我们输入URL后，我们的浏览器给Web服务器发送了一个Request, Web服务器接到Request后进行处理，生成相应的Response，然后发送给浏览器， 浏览器解析Response中的HTML,这样我们就看到了网页。 我们的Request 有可能是经过了代理服务器，最后才到达Web服务器的。 代理服务器就是网络信息的中转站，有什么功能呢？ 提高访问速度， 大多数的代理服务器都有缓存功能。 突破限制， 也就是FQ(翻墙)了 隐藏身份。 URL详解 URL(Uniform Resource Locator) 地址用于描述一个网络上的资源， 基本格式如下 schema://host[:port#]/path/…/[;url-params][?query-string][#anchor] scheme： 指定低层使用的协议(例如：http, https, ftp) host： HTTP服务器的IP地址或者域名 port#： HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 http://www.cnblogs.com:8080/ path： 访问资源的路径 url-params： query-string： 发送给http服务器的数据 anchor- : 锚 http://www.mywebsite.com/sj/test;id=8079?name=sviergn&amp;x=true#stuffSchema: httphost: www.mywebsite.compath: /sj/testURL params: id=8079Query String: name=sviergn&amp;x=trueAnchor: stuff HTTP协议是无状态的http协议是无状态的，同一个客户端的这次请求和上次请求是没有对应关系，对http服务器来说，它并不知道这两个请求来自同一个客户端。 为了解决这个问题， Web程序引入了Cookie机制来维护状态. HTTP消息的结构先看Request 消息的结构， Request 消息分为3部分，结构如下图 第一部分叫请求行， 第二部分叫http header, 第三部分是body. header和body之间有个空行， 第一行中的Method表示请求方法，比如”POST”，”GET”， Path-to-resoure表示请求的资源， Http/version-number 表示HTTP协议的版本号,当使用的是”GET” 方法的时候， body是为空的 Get和Post方法的区别Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息. 我们看看GET和POST的区别 GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中. GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制. GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。 GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码. 状态码Response 消息中的第一行叫做状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。 状态码用来告诉HTTP客户端，HTTP服务器是否产生了预期的Response. HTTP/1.1中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别 1XX 提示信息 - 表示请求已被成功接收，继续处理 2XX 成功 - 表示请求已被成功接收，理解，接受 3XX 重定向 - 要完成请求必须进行更进一步的处理 4XX 客户端错误 - 请求有语法错误或请求无法实现 5XX 服务器端错误 - 服务器未能实现合法的请求 看看一些常见的状态码200 OK —— 请求成功302 Found ——所请求的页面已经临时转移至新的url（新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。）304 Not Modified —— 代表上次的文档已经被缓存了， 还可以继续使用。400 Bad Request —— 客户端请求与语法错误，服务器未能理解请求。403 Forbidden —— 服务器收到请求，但是拒绝提供服务404 Not Found —— 请求资源不存在（输错了URL）500 Internal —— Server Error 服务器发生了不可预期的错误503 Server Unavailable —— 服务器当前不能处理客户端的请求，一段时间后可能恢复正常（请求未完成。服务器临时过载或当机）504 Gateway Timeout —— 网关超时 HTTP Request headerCache 头域If-Modified-Since 作用： 把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中。 If-None-Match 作用: If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和Etag. 使用这样的机制将提高网站的性能 Pragma 作用： 防止页面被缓存， 在HTTP/1.1版本中，它和Cache-Control:no-cache作用一模一样 Pargma只有一个用法， 例如： Pragma: no-cache 注意: 在HTTP/1.0版本中，只实现了Pragema:no-cache, 没有实现Cache-Control Cache-Control 作用: 这个是非常重要的规则。 这个用来指定Response-Request遵循的缓存机制。各个指令含义如下 Cache-Control:Public 可以被任何缓存所缓存（） Cache-Control:Private 内容只缓存到私有缓存中 Cache-Control:no-cache 所有内容都不会被缓存 还有其他的一些用法， 我没搞懂其中的意思， 请大家参考其他的资料 Client 头域Accept 作用： 浏览器端可以接受的媒体类型, 例如： Accept: text/html 代表浏览器可以接受服务器回发的类型为 text/html 也就是我们常说的html文档, 如果服务器无法返回text/html类型的数据，服务器应该返回一个406错误(non acceptable) 通配符 * 代表任意类型 例如 Accept: / 代表浏览器可以处理所有类型，(一般浏览器发给服务器都是发这个) Accept-Encoding： 作用： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）; 例如： Accept-Encoding: gzip, deflate Accept-Language 作用： 浏览器申明自己接收的语言。 语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等； 例如： Accept-Language: en-us User-Agent 作用：告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本. 我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。 例如： User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; CIBA; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; InfoPath.2; .NET4.0E) Accept-Charset 作用：浏览器申明自己接收的字符集，这就是本文前面介绍的各种字符集和字符编码，如gb2312，utf-8（通常我们说Charset包括了相应的字符编码方案）； 例如： Cookie/Login 头域Cookie: 作用： 最重要的header, 将cookie的值发送给HTTP 服务器 Entity头域Content-Length 作用：发送给HTTP服务器数据的长度。 例如： Content-Length: 38 Content-Type 作用： 例如：Content-Type: application/x-www-form-urlencoded Miscellaneous 头域Referer: 作用： 提供了Request的上下文信息的服务器，告诉服务器我是从哪个链接过来的，比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。 例如: Referer:http://translate.google.cn/?hl=zh-cn&amp;tab=wT Transport 头域Connection 例如： Connection: keep-alive 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接 例如： Connection: close 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。 Host（发送请求时，该报头域是必需的） 作用: 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的 例如: 我们在浏览器中输入：http://www.guet.edu.cn/index.html 浏览器发送的请求消息中，就会包含Host请求报头域，如下： Host：http://www.guet.edu.cn 此处使用缺省端口号80，若指定了端口号，则变成：Host：指定端口号 HTTP Response headerCache头域 #### Date 作用: 生成消息的具体时间和日期 例如： Date: Sat, 11 Feb 2012 11:35:14 GMT Expires 作用: 浏览器会在指定过期时间内使用本地缓存 例如: Expires: Tue, 08 Feb 2022 11:35:14 GMT Vary 作用： 例如: Vary: Accept-Encoding Cookie/Login 头域 P3P 作用: 用于跨域设置Cookie, 这样可以解决iframe跨域访问cookie的问题 例如: P3P: CP=CURa ADMa DEVa PSAo PSDo OUR BUS UNI PUR INT DEM STA PRE COM NAV OTC NOI DSP COR Set-Cookie 作用： 非常重要的header, 用于把cookie 发送到客户端浏览器， 每一个写入cookie都会生成一个Set-Cookie. 例如: Set-Cookie: sc=4c31523a; path=/; domain=.acookie.taobao.com Entity头域ETag 作用: 和If-None-Match 配合使用。 （实例请看上节中If-None-Match的实例） 例如: ETag: “03f2b33c0bfcc1:0” Last-Modified: 作用： 用于指示资源的最后修改日期和时间。（实例请看上节的If-Modified-Since的实例） 例如: Last-Modified: Wed, 21 Dec 2011 09:09:10 GMT Content-Type 作用：WEB服务器告诉浏览器自己响应的对象的类型和字符集, 例如: Content-Type: text/html; charset=utf-8 Content-Type:text/html;charset=GB2312 Content-Type: image/jpeg Content-Length 指明实体正文的长度，以字节方式存储的十进制数字来表示。在数据下行的过程中，Content-Length的方式要预先在服务器中缓存所有数据，然后所有数据再一股脑儿地发给客户端。 例如: Content-Length: 19847 Content-Encoding WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。 例如：Content-Encoding：gzip Content-Language 作用： WEB服务器告诉浏览器自己响应的对象的语言者 例如： Content-Language:da Miscellaneous 头域Server: 作用：指明HTTP服务器的软件信息 例如:Server: Microsoft-IIS/7.5 X-AspNet-Version: 作用：如果网站是用ASP.NET开发的，这个header用来表示ASP.NET的版本 例如: X-AspNet-Version: 4.0.30319 X-Powered-By: 作用：表示网站是用什么技术开发的 例如： X-Powered-By: ASP.NET Transport头域Connection: 例如： Connection: keep-alive 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接 例如： Connection: close 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。 Location头域Location: 作用： 用于重定向一个新的位置， 包含新的URL地址 实例请看304状态实例 HTTP协议是无状态的和Connection: keep-alive的区别 无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。 HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。 从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。 Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。125 0 原文参考：https://www.cnblogs.com/chaoran/p/4783633.html","tags":[{"name":"前端基础","slug":"前端基础","permalink":"https://yukiv587.github.io/blog/tags/前端基础/"}]},{"title":"前端基础知识","date":"2018-03-02T05:32:31.000Z","path":"2018/03/02/前端基础知识/","text":"理论知识网络七层协议从上到下： 7 应用层 —— 允许访问OSI环境的手段（应用协议数据单元APDU） 6 表示层 —— 对数据进行翻译、加密和压缩（表示协议数据单元PPDU） 5 会话层 —— 建立、管理和终止会话（会话协议数据单元SPDU） 4 传输层 —— 提供端到端的可靠报文传递和错误恢复（段Segment） 3 网络层 —— 负责数据包从源到宿的传递和网际互连（包PackeT） 2 数据链路层 —— 将比特组装成帧和点到点的传递（帧Frame） 1 物理层 —— 通过媒介传输比特,确定机械及电气规范（比特Bit） 304缓存的原理服务器首先产生ETag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。 304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件 客户端请求一个页面（A）。 服务器返回页面A，并在给A加上一个ETag。 客户端展现该页面，并将页面连同ETag一起缓存。 客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。 服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。 什么是Etag？当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断缓存文件是否过期。情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务器没有任何交互的。 情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和Etag 然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没有发生变化 情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧—— 304 Not Modified，此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服务器之间有一次请求交互。情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后的操作同① ① 只有get请求会被缓存，post请求不会 Expires和Cache-Control Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。 Cache-Control: no-cache, private, max-age=0 ETag: abcde Expires: Thu, 15 Apr 2014 20:00:00 GMT Pragma: private Last-Modified: $now // RFC1123 format ETag应用: Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验证资源是否修改。常见的是使用If-None-Match。请求一个文件的流程可能如下： ====第一次请求=== 1.客户端发起 HTTP GET 请求一个文件； 2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例如”2e681a-6-5d044840”)(假设服务器支持Etag生成和已经开启了Etag).状态码200====第二次请求=== 客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a-6-5d0448402.服务器判断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-Control:max-age和Expires呢，怎么办答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和Etag之后， 服务器才能返回304.(不要陷入到底使用谁的问题怪圈) 为什么使用Etag请求头? Etag 主要为了解决 Last-Modified 无法解决的一些问题。 Javascript垃圾回收方法 标记清除（mark and sweep） 这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。 垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了 引用计数(reference counting) 在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。 在IE中虽然JavaScript对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的，也就是说只要涉及BOM及DOM就会出现循环引用问题。","tags":[{"name":"HTML","slug":"HTML","permalink":"https://yukiv587.github.io/blog/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://yukiv587.github.io/blog/tags/CSS/"},{"name":"JS","slug":"JS","permalink":"https://yukiv587.github.io/blog/tags/JS/"}]},{"title":"github+hexo博客的主题安装及优化","date":"2018-02-24T06:58:44.461Z","path":"2018/02/24/github+hexo博客的主题安装及优化/","text":"在hexo官网有很多比较不错的主题推荐，可以在上面选择自己喜欢的主题，然后进行相应的个性化修改，这是我使用的主题indigo，通过github+hexo搭建个人博客。 安装Hexo在自己认为合适的地方创建一个文件夹，这里我以E：/hexo 为例子讲解，首先在E盘目录下创建Hexo文件夹，并在命令行的窗口进入到该目录 在命令行中输入：1npm install hexo-cli -g 然后你会看到命令行窗口刷了一大堆白字，下面我们来看一看Hexo是不是已经安装好了。 在命令行中输入：1hexo -v hexo的相关配置初始化Hexo1hexo init 然后输入：1npm install 之后npm将会自动安装你需要的组件，只需要等待npm操作即可。 首次体验Hexo12hexo ghexo s 在浏览器中打开http://localhost:4000/，你将会看到： 安装主题选择一款自己喜欢的主题，这将成为你个人博客模版。这里是主题安装的教程，下面是我安装时的经验及个人见解。安装需确认你的 Hexo 版本在 3.0 以上，以及 Node 版本为 6.x 以上，在 Hexo 根目录，执行以下命令。1git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo 这个命令要在博客文件夹的根目录右击鼠标打开Git Bash输入命令，其中themes/indigo就是会在博客文件夹根目录中的themes新建一个indigo文件夹存放clone下来的主题，以后的主题通常都是存放在这个目录下。通俗来说就是这样git clone +通过主题的github中获取的URL+ +themes/indigo 将Hexo与Github page联系起来设置Git的user name和email（如果是第一次的话） 上图是在其文件夹里面鼠标右键，点击Git Base Here。这里“feng”可以替换成自己的用户名，邮箱可以替换成自己的邮箱 输入cd ~/.ssh，检查是否由.ssh的文件夹 输入ls，列出该文件下的内容。下图说明存在 输入ssh-keygen -t rsa -C “929762930@qq.com”，连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\\Users\\Administrator.ssh）。 输入eval “$(ssh-agent -s)”，添加密钥到ssh-agent 再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent 登录github官网账号，点击头像下的settings，添加ssh 新建一个new ssh key，将id_rsa.pub文件里的内容复制上去 输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了 问题：假如ssh-key配置失败，那么只要以下步骤就能完全解决 首先，清除所有的key-pairssh-add -Drm -r ~/.ssh删除你在github中的public-key 重新生成ssh密钥对ssh-keygen -t rsa -C “xxx@xxx.com” 接下来正常操作在github上添加公钥public-key:1、首先在你的终端运行 xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪切板2、在github上添加公钥时，直接复制即可3、保存 测试：在终端 ssh -T git@github.com 配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾） repo值是你在github项目里的ssh（右下角） 新建一篇博客，在cmd执行命令：hexo new post “博客名” 需要安装一个扩展：1npm install hexo-deployer-git --save 那么就可以使用命令：hexo d -g，生成以及部署了部署成功后访问你的地址：”http://用户名.github.io “。那么将看到生成的文章","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://yukiv587.github.io/blog/tags/Hexo/"}]},{"title":"CSS实用Tips","date":"2018-02-08T07:13:51.000Z","path":"2018/02/08/CSS实用Tips/","text":"作为自己做前端开发以来的CSS爬坑总结，内容偏向PC端，不定期补充。只作提示，不深谈。 盒子模型 a b c 1、区分content-box和border-box的尺寸计算。 2、行级元素无宽高，但可设内外边距。 3、外边距margin可设负值，内边距padding不可以。 4、当内外边距值为百分比时是相对于元素宽度计算的。 5、border是个好玩的东西，关键字：css三角形。 1alert(&apos;Hello World!&apos;);","tags":[{"name":"HTML","slug":"HTML","permalink":"https://yukiv587.github.io/blog/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://yukiv587.github.io/blog/tags/CSS/"},{"name":"JS","slug":"JS","permalink":"https://yukiv587.github.io/blog/tags/JS/"}]},{"title":"常用网站","date":"2018-02-08T02:36:26.000Z","path":"2018/02/08/常用网站/","text":"参考手册 css参考手册 css3参考手册 jquery手册 前端框架 Bootstrop vue vux hexo 学习资料 前端导航 ES6 微信小程序文档 markdown 语法说明 插件css样式重置 normalize.css CSS reset 动画库 Animate.css Effeckt.css magic.css csshake.css – 抖动动画 snabbt.js JQuery插件 JQuery插件库 JQuery之家 jqueryfuns– 响应式模板 fullPage.js–全屏滚动插件 myFocus – js焦点轮播 工具 贝塞尔曲线css3绘制工具 素材网 图片压缩 阿里巴巴矢量图 ionicons–图标 面试题库 2017年前端面试题整理汇总100题 前端面试题目搜集","tags":[]}]